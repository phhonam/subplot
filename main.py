# Movie Recommender Project Setup and Basic Implementation
# This file contains the complete setup and basic functionality

import json
import os
from dataclasses import dataclass
from typing import List, Dict, Any
import requests
from datetime import datetime

# Required LLM imports
import openai
from dotenv import load_dotenv
import anthropic


# First, install required packages:
# pip install openai python-dotenv requests

# For local LLM option, also install:
# pip install ollama

# Add the new taxonomy constants at the top of the file
EMOTIONAL_TONE_CATEGORIES = [
    "uplifting",      # hopeful, inspirational, heartwarming
    "melancholic",    # bittersweet, poignant, reflective
    "tense",          # suspenseful, unnerving, anxious
    "comedic",        # humorous, lighthearted, witty
    "dramatic",       # intense, emotional, powerful
    "contemplative",  # thoughtful, introspective, meditative
    "dark",           # bleak, disturbing, unsettling
    "romantic"        # passionate, tender, intimate
]

THEME_CATEGORIES = [
    # Identity & Self-Discovery
    "coming_of_age",        # teenage angst, first love, finding yourself
    "midlife_crisis",       # career changes, relationship reevaluation, existential questioning
    "identity_crisis",      # who am I really? cultural identity, gender identity
    
    # Relationships & Connection
    "found_family",         # chosen family, unlikely friendships, community bonds
    "toxic_relationships",  # codependency, manipulation, unhealthy dynamics
    "forbidden_love",       # taboo romance, star-crossed lovers, social barriers
    "loneliness_isolation", # social alienation, urban isolation, emotional distance
    
    # Power & Society
    "class_warfare",        # rich vs poor, social mobility, economic inequality
    "institutional_corruption", # systemic abuse, cover-ups, whistleblowing
    "surveillance_control", # big brother, privacy invasion, authoritarianism
    "media_manipulation",   # fake news, propaganda, truth vs perception
    
    # Survival & Resilience
    "underdog_triumph",     # beating the odds, small vs big, David vs Goliath
    "post_apocalyptic",     # end of world, rebuilding society, resource scarcity
    "mental_health_struggle", # depression, addiction, trauma recovery
    "immigrant_experience", # cultural adaptation, language barriers, belonging
    
    # Art & Creativity
    "artistic_obsession",   # creative madness, perfectionism, artistic sacrifice
    "performance_anxiety",  # stage fright, imposter syndrome, public scrutiny
    "creative_block",       # writer's block, artistic crisis, inspiration loss
    
    # Time & Memory
    "nostalgia_longing",    # past regrets, lost opportunities, what could have been
    "time_travel_paradox",  # changing the past, multiple timelines, fate vs choice
    "memory_loss",          # amnesia, dementia, unreliable narrator
    
    # Technology & Future
    "ai_consciousness",     # artificial intelligence, what makes us human
    "virtual_reality",      # digital worlds, reality vs simulation
    "technological_dystopia", # tech gone wrong, digital surveillance, automation
    
    # Nature & Environment
    "environmental_crisis", # climate change, ecological disaster, human impact
    "wilderness_survival",  # nature vs civilization, back to basics, primal instincts
    "cosmic_horror",        # vast unknown, existential dread, cosmic insignificance
    
    # Crime & Justice
    "moral_ambiguity",      # gray areas, difficult choices, no clear heroes
    "revenge_justice",      # vigilante justice, personal vendettas, eye for an eye
    "organized_crime",      # mafia, gangs, criminal underworld
    
    # War & Conflict
    "war_trauma",           # PTSD, survivor's guilt, war's lasting effects
    "civil_unrest",         # protests, revolutions, social upheaval
]

@dataclass
class MovieProfile:
    """Structured movie profile generated by LLM"""
    title: str
    primary_emotional_tone: str      # Single primary tone from categories
    secondary_emotional_tone: str    # Optional secondary tone or "none"
    primary_theme: str               # Single primary theme from categories
    secondary_theme: str             # Optional secondary theme or "none"
    intensity_level: str             # "low", "medium", "high"
    pacing_style: str
    visual_aesthetic: str
    target_audience: str
    similar_films: List[str]
    cultural_context: List[str]  # Cultural/social elements and background
    narrative_structure: str  # How the story is told and organized
    energy_level: str  # Intensity of viewing experience
    discussion_topics: List[str]  # What conversations/thoughts it sparks
    card_description: str  # Short, punchy description for movie cards
    profile_text: str


class LLMProfileGenerator:
    """Handles LLM integration for generating movie profiles"""

    def __init__(self, provider="openai"):
        self.provider = provider
        self.setup_llm()

    def setup_llm(self):
        """Initialize LLM connection"""
        # Load environment variables
        load_dotenv()

        if self.provider == "openai":
            self.client = openai.OpenAI(
                api_key=os.getenv("OPENAI_API_KEY")
            )

        elif self.provider == "anthropic":
            self.client = anthropic.Anthropic(
                api_key=os.getenv("ANTHROPIC_API_KEY")
            )

        elif self.provider == "ollama":
            # For local LLM using Ollama
            self.base_url = "http://localhost:11434"
            print("Using local Ollama. Make sure it's running: ollama serve")

    def generate_profile(self, movie_data: Dict) -> MovieProfile:
        """Generate a structured movie profile using LLM"""

        prompt = self._create_profile_prompt(movie_data)

        if self.provider == "openai":
            response = self._call_openai(prompt)
        elif self.provider == "anthropic":
            response = self._call_anthropic(prompt)
        elif self.provider == "ollama":
            response = self._call_ollama(prompt)

        return self._parse_profile_response(response, movie_data['title'])

    def propose_theme(self, input_type: str, input_data: str, movie_database: Dict = None, existing_proposals: List[Dict] = None) -> Dict[str, Any]:
        """Generate a theme proposal using LLM"""
        
        if input_type == "auto":
            prompt = self._create_auto_discovery_prompt(movie_database, existing_proposals)
        elif input_type == "movies":
            prompt = self._create_movie_analysis_prompt(input_data)
        elif input_type == "description":
            prompt = self._create_description_prompt(input_data)
        else:
            raise ValueError(f"Invalid input_type: {input_type}")

        if self.provider == "openai":
            response = self._call_openai(prompt)
        elif self.provider == "anthropic":
            response = self._call_anthropic(prompt)
        elif self.provider == "ollama":
            response = self._call_ollama(prompt)

        return self._parse_theme_proposal_response(response, input_type, input_data)

    def _create_auto_discovery_prompt(self, movie_database: Dict, existing_proposals: List[Dict] = None) -> str:
        """Create prompt for auto-discovering themes from database"""
        
        # Sample movies from database (up to 100) with randomization
        all_movies = list(movie_database.values()) if movie_database else []
        import random
        sample_movies = random.sample(all_movies, min(100, len(all_movies)))  # Random sample for diversity
        
        # Create movie summaries for analysis
        movie_summaries = []
        for movie in sample_movies:
            summary = f"Title: {movie.get('title', 'Unknown')}\n"
            summary += f"Plot: {movie.get('plot_summary', 'No plot available')}\n"
            summary += f"Genres: {', '.join(movie.get('genre_tags', []))}\n"
            summary += f"Current Themes: {movie.get('primary_theme', 'none')}, {movie.get('secondary_theme', 'none')}\n"
            movie_summaries.append(summary)
        
        movies_text = "\n---\n".join(movie_summaries)
        
        # Get current themes
        current_themes = "\n".join([f"- {theme}" for theme in THEME_CATEGORIES])
        
        # Add existing proposals to avoid duplicates
        existing_proposals_text = ""
        if existing_proposals:
            existing_proposals_text = "\n\nEXISTING PENDING PROPOSALS (DO NOT DUPLICATE):\n"
            for proposal in existing_proposals:
                existing_proposals_text += f"- {proposal.get('theme_name', '')}: {proposal.get('description', '')}\n"
        
        return f"""
You are an expert film analyst tasked with discovering new thematic categories that are missing from our current taxonomy.

CURRENT THEME CATEGORIES:
{current_themes}
{existing_proposals_text}

SAMPLE MOVIES FROM DATABASE (randomized for diversity):
{movies_text}

ANALYSIS TASK:
Analyze the sample movies above and identify thematic patterns that are NOT well-covered by our existing 28 theme categories. Look for:

1. Recurring themes that appear in multiple movies but don't fit existing categories
2. Niche but meaningful thematic elements that could help users find similar films
3. Cultural, social, or psychological themes that are underrepresented
4. AVOID themes that are too similar to existing ones (like "existential_journey" when we have "identity_crisis")
5. DO NOT propose themes similar to existing pending proposals listed above

REQUIREMENTS:
- Propose only ONE new theme that would be most valuable to add
- The theme should be DISTINCT and DIFFERENT from existing categories AND pending proposals
- It should apply to at least 8-12 movies in the sample
- Focus on themes that would help users discover films they'd enjoy
- Avoid themes that overlap significantly with existing ones
- Consider themes from different categories: social, psychological, cultural, technological, etc.

RESPONSE FORMAT:
THEME_NAME: [snake_case_theme_name]
DESCRIPTION: [brief description similar to existing themes]
EXAMPLES: [8-12 movie titles from the sample that fit this theme, separated by commas]
REASONING: [explanation of why this theme is needed and how it differs from existing categories]

Focus on themes that would genuinely help users find movies they'd love and are clearly different from existing themes and pending proposals.
"""

    def _create_movie_analysis_prompt(self, movie_titles: str) -> str:
        """Create prompt for analyzing specific movies to propose a theme"""
        
        current_themes = "\n".join([f"- {theme}" for theme in THEME_CATEGORIES])
        
        return f"""
You are an expert film analyst. I'm going to give you a list of movies, and I want you to identify what thematic element they share that isn't well-covered by our existing theme categories.

CURRENT THEME CATEGORIES:
{current_themes}

MOVIES TO ANALYZE:
{movie_titles}

TASK:
Analyze these movies and identify a common thematic element that:
1. Is NOT well-covered by our existing 28 theme categories
2. Would help users discover similar films
3. Is meaningful and specific enough to be useful

RESPONSE FORMAT:
THEME_NAME: [snake_case_theme_name]
DESCRIPTION: [brief description similar to existing themes]
EXAMPLES: [the movies provided plus 5-7 additional similar movies, separated by commas]
REASONING: [explanation of the common theme and why it's not covered by existing categories]

Focus on what makes these movies thematically similar and why that theme would be valuable for movie discovery.
"""

    def _create_description_prompt(self, description: str) -> str:
        """Create prompt for generating theme from description"""
        
        current_themes = "\n".join([f"- {theme}" for theme in THEME_CATEGORIES])
        
        return f"""
You are an expert film analyst. I'm describing a thematic gap in our movie categorization system, and I want you to propose a new theme category to fill it.

CURRENT THEME CATEGORIES:
{current_themes}

THEMATIC GAP DESCRIPTION:
{description}

TASK:
Based on this description, propose a new theme category that:
1. Is NOT covered by our existing 28 theme categories
2. Would be useful for helping users discover movies
3. Is specific and meaningful
4. Follows the naming and description style of existing themes

RESPONSE FORMAT:
THEME_NAME: [snake_case_theme_name]
DESCRIPTION: [brief description similar to existing themes]
EXAMPLES: [8-12 well-known movies that would fit this theme, separated by commas]
REASONING: [explanation of why this theme is needed and how it differs from existing categories]

Make sure the proposed theme is distinct and valuable for movie discovery.
"""

    def _parse_theme_proposal_response(self, response: str, input_type: str, input_data: str) -> Dict[str, Any]:
        """Parse LLM response into structured theme proposal"""
        
        lines = response.strip().split('\n')
        proposal_data = {
            'theme_name': '',
            'description': '',
            'examples': [],
            'reasoning': '',
            'input_type': input_type,
            'input_data': input_data
        }
        
        current_section = None
        
        for line in lines:
            line = line.strip()
            if line.startswith('THEME_NAME:'):
                proposal_data['theme_name'] = line.split(':', 1)[1].strip()
            elif line.startswith('DESCRIPTION:'):
                proposal_data['description'] = line.split(':', 1)[1].strip()
            elif line.startswith('EXAMPLES:'):
                examples_text = line.split(':', 1)[1].strip()
                proposal_data['examples'] = [ex.strip() for ex in examples_text.split(',')]
            elif line.startswith('REASONING:'):
                current_section = 'reasoning'
                proposal_data['reasoning'] = line.split(':', 1)[1].strip()
            elif current_section == 'reasoning' and line:
                proposal_data['reasoning'] += ' ' + line
        
        # Validate required fields
        if not proposal_data['theme_name'] or not proposal_data['description']:
            raise ValueError("Invalid theme proposal response: missing required fields")
        
        return proposal_data

    def _create_profile_prompt(self, movie_data: Dict) -> str:
        """Create the prompt for LLM profile generation with simplified taxonomy"""

        # Combine reviews for context
        critic_reviews = "\n".join(movie_data.get('critic_reviews', [])[:2])
        user_reviews = "\n".join(movie_data.get('user_reviews', [])[:2])
        
        # Create the theme categories list for the prompt
        theme_list = "\n".join([f"- {theme}: {desc}" for theme, desc in [
            ("coming_of_age", "teenage angst, first love, finding yourself"),
            ("midlife_crisis", "career changes, relationship reevaluation, existential questioning"),
            ("identity_crisis", "who am I really? cultural identity, gender identity"),
            ("found_family", "chosen family, unlikely friendships, community bonds"),
            ("toxic_relationships", "codependency, manipulation, unhealthy dynamics"),
            ("forbidden_love", "taboo romance, star-crossed lovers, social barriers"),
            ("loneliness_isolation", "social alienation, urban isolation, emotional distance"),
            ("class_warfare", "rich vs poor, social mobility, economic inequality"),
            ("institutional_corruption", "systemic abuse, cover-ups, whistleblowing"),
            ("surveillance_control", "big brother, privacy invasion, authoritarianism"),
            ("media_manipulation", "fake news, propaganda, truth vs perception"),
            ("underdog_triumph", "beating the odds, small vs big, David vs Goliath"),
            ("post_apocalyptic", "end of world, rebuilding society, resource scarcity"),
            ("mental_health_struggle", "depression, addiction, trauma recovery"),
            ("immigrant_experience", "cultural adaptation, language barriers, belonging"),
            ("artistic_obsession", "creative madness, perfectionism, artistic sacrifice"),
            ("performance_anxiety", "stage fright, imposter syndrome, public scrutiny"),
            ("creative_block", "writer's block, artistic crisis, inspiration loss"),
            ("nostalgia_longing", "past regrets, lost opportunities, what could have been"),
            ("time_travel_paradox", "changing the past, multiple timelines, fate vs choice"),
            ("memory_loss", "amnesia, dementia, unreliable narrator"),
            ("ai_consciousness", "artificial intelligence, what makes us human"),
            ("virtual_reality", "digital worlds, reality vs simulation"),
            ("technological_dystopia", "tech gone wrong, digital surveillance, automation"),
            ("environmental_crisis", "climate change, ecological disaster, human impact"),
            ("wilderness_survival", "nature vs civilization, back to basics, primal instincts"),
            ("cosmic_horror", "vast unknown, existential dread, cosmic insignificance"),
            ("moral_ambiguity", "gray areas, difficult choices, no clear heroes"),
            ("revenge_justice", "vigilante justice, personal vendettas, eye for an eye"),
            ("organized_crime", "mafia, gangs, criminal underworld"),
            ("war_trauma", "PTSD, survivor's guilt, war's lasting effects"),
            ("civil_unrest", "protests, revolutions, social upheaval"),
            ("cold_war_espionage", "spies, double agents, political intrigue")
        ]])

        prompt = f"""
Analyze this indie film and map it to our standardized categories:

MOVIE DATA:
Title: {movie_data['title']} ({movie_data['year']})
Director: {movie_data['director']}
Genres: {', '.join(movie_data.get('genre_tags', []))}
Plot: {movie_data['plot_summary']}
Visual Style: {movie_data.get('visual_style', 'Not specified')}

Critic Reviews:
{critic_reviews}

User Reviews:
{user_reviews}

EMOTIONAL TONE CATEGORIES (choose 1-2):
- uplifting: hopeful, inspirational, heartwarming
- melancholic: bittersweet, poignant, reflective  
- tense: suspenseful, unnerving, anxious
- comedic: humorous, lighthearted, witty
- dramatic: intense, emotional, powerful
- contemplative: thoughtful, introspective, meditative
- dark: bleak, disturbing, unsettling
- romantic: passionate, tender, intimate

THEME CATEGORIES (choose 1-2):
{theme_list}

Generate response in this exact format:
PRIMARY_EMOTIONAL_TONE: [single category from emotional tone list]
SECONDARY_EMOTIONAL_TONE: [optional second category or "none"]
PRIMARY_THEME: [single category from theme list]
SECONDARY_THEME: [optional second category or "none"]
INTENSITY_LEVEL: [low/medium/high]
PACING_STYLE: [single phrase describing pace]
VISUAL_AESTHETIC: [brief description of visual style]
TARGET_AUDIENCE: [who would most enjoy this film]
SIMILAR_FILMS: [3-4 comparable films separated by commas]
CULTURAL_CONTEXT: [2-4 cultural/social elements separated by commas]
NARRATIVE_STRUCTURE: [single phrase describing how story is told]
ENERGY_LEVEL: [single phrase describing viewing intensity]
DISCUSSION_TOPICS: [3-4 conversation topics this film sparks, separated by commas]

CARD_DESCRIPTION: [1-2 sentences that capture the unique essence and appeal of this film - what makes it special and why someone should watch it. Focus on the most distinctive theme, visual style, or emotional experience. Keep it punchy and engaging, like a movie tagline or elevator pitch.]

PROFILE_SUMMARY:
[2-3 paragraph detailed analysis of the film's unique qualities, appeal, and what makes it distinctive in the indie film landscape]

Focus on what makes this film unique and what kind of viewer would connect with it.
"""
        return prompt

    def _call_openai(self, prompt: str) -> str:
        """Call OpenAI API"""
        try:
            # Enhanced system prompt for better profile generation
            system_prompt = """You are an expert indie film analyst with deep knowledge of:
- Independent cinema history and movements (Mumblecore, New Wave, etc.)
- Film festival circuits (Sundance, Cannes, SXSW, Toronto)
- Arthouse and auteur filmmaking styles
- Audience psychology and viewing preferences
- Contemporary streaming and distribution trends

Your task is to create precise, insightful movie profiles that capture the unique essence of each film. Focus on:
- Specific emotional and aesthetic qualities that differentiate films
- Themes that resonate with particular viewer types
- Visual and narrative styles that define the viewing experience
- Cultural and social contexts that shape audience appeal

Be analytical, specific, and avoid generic descriptions. Use nuanced language that reflects deep film knowledge."""

            response = self.client.chat.completions.create(
                model="gpt-3.5-turbo",  # or "gpt-4" for better quality
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": prompt}
                ],
                max_tokens=800,
                temperature=0.7
            )
            return response.choices[0].message.content
        except Exception as e:
            print(f"Error calling OpenAI: {e}")
            return self._fallback_profile()

    def _call_anthropic(self, prompt: str) -> str:
        """Call Anthropic API"""
        try:
            response = self.client.messages.create(
                model="claude-3-sonnet-20240229",
                max_tokens=800,
                messages=[
                    {"role": "user", "content": prompt}
                ]
            )
            return response.content[0].text
        except Exception as e:
            print(f"Error calling Anthropic: {e}")
            return self._fallback_profile()

    def _call_ollama(self, prompt: str) -> str:
        """Call local Ollama API"""
        try:
            response = requests.post(
                f"{self.base_url}/api/generate",
                json={
                    "model": "llama2",  # or any model you have installed
                    "prompt": prompt,
                    "stream": False
                }
            )
            return response.json()['response']
        except Exception as e:
            print(f"Error calling Ollama: {e}")
            return self._fallback_profile()

    def _fallback_profile(self) -> str:
        """Fallback response if LLM fails"""
        return """
EMOTIONAL_TONE: contemplative, authentic, nuanced
THEMES: identity, family, coming-of-age, cultural conflict
PACING_STYLE: measured and deliberate
VISUAL_AESTHETIC: naturalistic with intimate framing
TARGET_AUDIENCE: thoughtful viewers who appreciate character-driven stories
SIMILAR_FILMS: The Florida Project, Waves, Columbus
CULTURAL_CONTEXT: contemporary social issues, cross-generational relationships, economic realities
NARRATIVE_STRUCTURE: character study with observational storytelling
ENERGY_LEVEL: contemplative and emotionally engaging
DISCUSSION_TOPICS: personal identity, family relationships, social expectations, life transitions

PROFILE_SUMMARY:
This film represents the kind of authentic, character-driven storytelling that defines quality independent cinema. With its focus on genuine human relationships and cultural specificity, it appeals to viewers who prefer substance over spectacle.
"""

    def _parse_profile_response(self, response: str, title: str) -> MovieProfile:
        """Parse LLM response into structured MovieProfile"""

        lines = response.strip().split('\n')
        profile_data = {
            'primary_emotional_tone': '',
            'secondary_emotional_tone': '',
            'primary_theme': '',
            'secondary_theme': '',
            'intensity_level': '',
            'pacing_style': '',
            'visual_aesthetic': '',
            'target_audience': '',
            'similar_films': [],
            'cultural_context': [],
            'narrative_structure': '',
            'energy_level': '',
            'discussion_topics': [],
            'card_description': '',
            'profile_text': ''
        }

        # Parse structured response
        current_section = None
        profile_summary_lines = []

        for line in lines:
            line = line.strip()
            if line.startswith('PRIMARY_EMOTIONAL_TONE:'):
                profile_data['primary_emotional_tone'] = line.split(':', 1)[1].strip()
            elif line.startswith('SECONDARY_EMOTIONAL_TONE:'):
                profile_data['secondary_emotional_tone'] = line.split(':', 1)[1].strip()
            elif line.startswith('PRIMARY_THEME:'):
                profile_data['primary_theme'] = line.split(':', 1)[1].strip()
            elif line.startswith('SECONDARY_THEME:'):
                profile_data['secondary_theme'] = line.split(':', 1)[1].strip()
            elif line.startswith('INTENSITY_LEVEL:'):
                profile_data['intensity_level'] = line.split(':', 1)[1].strip()
            elif line.startswith('PACING_STYLE:'):
                profile_data['pacing_style'] = line.split(':', 1)[1].strip()
            elif line.startswith('VISUAL_AESTHETIC:'):
                profile_data['visual_aesthetic'] = line.split(':', 1)[1].strip()
            elif line.startswith('TARGET_AUDIENCE:'):
                profile_data['target_audience'] = line.split(':', 1)[1].strip()
            elif line.startswith('SIMILAR_FILMS:'):
                profile_data['similar_films'] = [x.strip() for x in line.split(':', 1)[1].split(',')]
            elif line.startswith('CULTURAL_CONTEXT:'):
                profile_data['cultural_context'] = [x.strip() for x in line.split(':', 1)[1].split(',')]
            elif line.startswith('NARRATIVE_STRUCTURE:'):
                profile_data['narrative_structure'] = line.split(':', 1)[1].strip()
            elif line.startswith('ENERGY_LEVEL:'):
                profile_data['energy_level'] = line.split(':', 1)[1].strip()
            elif line.startswith('DISCUSSION_TOPICS:'):
                profile_data['discussion_topics'] = [x.strip() for x in line.split(':', 1)[1].split(',')]
            elif line.startswith('CARD_DESCRIPTION:'):
                profile_data['card_description'] = line.split(':', 1)[1].strip()
            elif line.startswith('PROFILE_SUMMARY:'):
                current_section = 'summary'
            elif current_section == 'summary' and line:
                profile_summary_lines.append(line)

        profile_data['profile_text'] = '\n'.join(profile_summary_lines)

        return MovieProfile(
            title=title,
            primary_emotional_tone=profile_data['primary_emotional_tone'],
            secondary_emotional_tone=profile_data['secondary_emotional_tone'],
            primary_theme=profile_data['primary_theme'],
            secondary_theme=profile_data['secondary_theme'],
            intensity_level=profile_data['intensity_level'],
            pacing_style=profile_data['pacing_style'],
            visual_aesthetic=profile_data['visual_aesthetic'],
            target_audience=profile_data['target_audience'],
            similar_films=profile_data['similar_films'],
            cultural_context=profile_data['cultural_context'],
            narrative_structure=profile_data['narrative_structure'],
            energy_level=profile_data['energy_level'],
            discussion_topics=profile_data['discussion_topics'],
            card_description=profile_data['card_description'],
            profile_text=profile_data['profile_text']
        )


class MovieRecommender:
    """Main class for movie recommendation system"""

    def __init__(self, llm_provider="openai"):
        self.profile_generator = LLMProfileGenerator(llm_provider)
        self.movie_profiles = {}
        self.raw_movie_data = {}

    def load_movie_data(self, json_file_path: str):
        """Load movie data from JSON file"""
        with open(json_file_path, 'r') as f:
            data = json.load(f)
            self.raw_movie_data = {movie['title']: movie for movie in data['movies']}

    def generate_all_profiles(self):
        """Generate LLM profiles for all movies"""
        print("Generating movie profiles...")
        for title, movie_data in self.raw_movie_data.items():
            print(f"Processing: {title}")
            profile = self.profile_generator.generate_profile(movie_data)
            self.movie_profiles[title] = profile
            print(f"âœ“ Generated profile for {title}")
        print("All profiles generated!")

    def save_profiles(self, output_file: str):
        """Save generated profiles to JSON"""
        profiles_dict = {}
        for title, profile in self.movie_profiles.items():
            profiles_dict[title] = {
                'title': profile.title,
                'primary_emotional_tone': profile.primary_emotional_tone,
                'secondary_emotional_tone': profile.secondary_emotional_tone,
                'primary_theme': profile.primary_theme,
                'secondary_theme': profile.secondary_theme,
                'intensity_level': profile.intensity_level,
                'pacing_style': profile.pacing_style,
                'visual_aesthetic': profile.visual_aesthetic,
                'target_audience': profile.target_audience,
                'similar_films': profile.similar_films,
                'cultural_context': profile.cultural_context,
                'narrative_structure': profile.narrative_structure,
                'energy_level': profile.energy_level,
                'discussion_topics': profile.discussion_topics,
                'card_description': profile.card_description,
                'profile_text': profile.profile_text
            }

        with open(output_file, 'w') as f:
            json.dump(profiles_dict, f, indent=2)
        print(f"Profiles saved to {output_file}")

    def display_profile(self, title: str):
        """Display a movie profile in a readable format"""
        if title not in self.movie_profiles:
            print(f"Profile not found for: {title}")
            return

        profile = self.movie_profiles[title]
        print(f"\n{'=' * 50}")
        print(f"MOVIE PROFILE: {profile.title}")
        print(f"{'=' * 50}")
        print(f"Primary Emotional Tone: {profile.primary_emotional_tone}")
        print(f"Secondary Emotional Tone: {profile.secondary_emotional_tone}")
        print(f"Primary Theme: {profile.primary_theme}")
        print(f"Secondary Theme: {profile.secondary_theme}")
        print(f"Intensity Level: {profile.intensity_level}")
        print(f"Pacing: {profile.pacing_style}")
        print(f"Visual Style: {profile.visual_aesthetic}")
        print(f"Target Audience: {profile.target_audience}")
        print(f"Similar Films: {', '.join(profile.similar_films)}")
        print(f"Cultural Context: {profile.cultural_context}")
        print(f"Narrative Structure: {profile.narrative_structure}")
        print(f"Energy Level: {profile.energy_level}")
        print(f"Discussion Topics: {', '.join(profile.discussion_topics)}")
        print(f"Card Description: {profile.card_description}")
        print(f"\nProfile Summary:")
        print(profile.profile_text)
        print(f"{'=' * 50}\n")


# Example usage and testing
def main():
    """Example usage of the movie recommender system"""

    # Initialize recommender (choose your LLM provider)
    # Options: "openai", "anthropic", "ollama"
    recommender = MovieRecommender(llm_provider="openai")

    # Load mock data
    recommender.load_movie_data('mock_movie_data.json')

    # Generate profiles for all movies
    recommender.generate_all_profiles()

    # Save profiles
    recommender.save_profiles('movie_profiles.json')

    # Display a sample profile
    recommender.display_profile("The Farewell")

    # Display all available movies
    print("Available movies:")
    for title in recommender.raw_movie_data.keys():
        print(f"- {title}")

if __name__ == "__main__":
    main()